[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "watsy0007",
    "section": "",
    "text": "使用 DuckDB 查找空缺的日期\n\n\n4 min\n\n\n\n\n\n\nJul 26, 2024\n\n\n\n\n\n\n\n\n\n\n\n\nDuckDB Example\n\n\n1 min\n\n\n\n\n\n\nFeb 17, 2024\n\n\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/duckdb-example/index.html",
    "href": "posts/duckdb-example/index.html",
    "title": "DuckDB Example",
    "section": "",
    "text": "基于 quarto 测试 DuckDB 功能。\n\n以下所有代码可以复制到 jupyter notebook 中执行。\n\n安装依赖\n\n!pip install duckdb jupysql --quiet\n\n\n\n基础配置\n\nimport duckdb\n\nconn = duckdb.connect()\n\njupysql 配置\n\n%load_ext sql\n\n%config SqlMagic.autopandas = True\n%config SqlMagic.feedback = 0\n%config SqlMagic.displaycon = True\n%config SqlMagic.displaylimit = 10\n\n%sql conn --alias duckdb-native\n\n\n\n演示数据\n参考 Jupyter Notebooks\n\n%%sql --save short_trips --no-execute\nSELECT *\nFROM 'https://d37ci6vzurychx.cloudfront.net/trip-data/yellow_tripdata_2021-01.parquet'\nWHERE trip_distance &lt; 6.3\n\nSkipping execution...\n\n\n\n%sqlplot histogram --table short_trips --column trip_distance --bins 10 --with short_trips"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "Elven | Head Data Scientist | June 2018 - present"
  },
  {
    "objectID": "about.html#experience",
    "href": "about.html#experience",
    "title": "About",
    "section": "",
    "text": "Elven | Head Data Scientist | June 2018 - present"
  },
  {
    "objectID": "posts/find_missing_dates_with_duckdb/index.html#获取数据",
    "href": "posts/find_missing_dates_with_duckdb/index.html#获取数据",
    "title": "使用 DuckDB 查找空缺的日期",
    "section": "1. 获取数据",
    "text": "1. 获取数据\n这里使用 mock 数据\n\n\nCode\nimport duckdb\n\nconn = duckdb.connect()\n\nmock_data_sql = \"\"\"\nSELECT * FROM (\n    VALUES \n      (1, DATE '2024-07-01'),\n      (1, DATE '2024-07-02'),\n      (1, DATE '2024-07-03'),\n      (1, DATE '2024-07-05'),\n      (1, DATE '2024-07-06'),\n      (2, DATE '2024-07-01'),\n      (2, DATE '2024-07-02'),\n      (2, DATE '2024-07-03'),\n      (3, DATE '2024-07-01'),\n      (3, DATE '2024-07-02'),\n      (3, DATE '2024-07-03'),\n      (3, DATE '2024-07-04'),\n      (3, DATE '2024-07-05'),\n      (3, DATE '2024-07-06'),\n      (3, DATE '2024-07-07'),\n      (3, DATE '2024-07-08'),\n      (3, DATE '2024-07-09'),\n      (4, DATE '2024-07-05'),\n      (4, DATE '2024-07-06'),\n      (4, DATE '2024-07-07'),\n      (4, DATE '2024-07-08'),\n      (4, DATE '2024-07-09'),\n  ) AS t(source_id, end_date)\n\"\"\"\ndf = conn.execute(mock_data_sql).df()\ndf\n\n\n\n\n\n\n\n\n\nsource_id\nend_date\n\n\n\n\n0\n1\n2024-07-01\n\n\n1\n1\n2024-07-02\n\n\n2\n1\n2024-07-03\n\n\n3\n1\n2024-07-05\n\n\n4\n1\n2024-07-06\n\n\n5\n2\n2024-07-01\n\n\n6\n2\n2024-07-02\n\n\n7\n2\n2024-07-03\n\n\n8\n3\n2024-07-01\n\n\n9\n3\n2024-07-02\n\n\n10\n3\n2024-07-03\n\n\n11\n3\n2024-07-04\n\n\n12\n3\n2024-07-05\n\n\n13\n3\n2024-07-06\n\n\n14\n3\n2024-07-07\n\n\n15\n3\n2024-07-08\n\n\n16\n3\n2024-07-09\n\n\n17\n4\n2024-07-05\n\n\n18\n4\n2024-07-06\n\n\n19\n4\n2024-07-07\n\n\n20\n4\n2024-07-08\n\n\n21\n4\n2024-07-09"
  },
  {
    "objectID": "posts/find_missing_dates_with_duckdb/index.html#对时间进行分组",
    "href": "posts/find_missing_dates_with_duckdb/index.html#对时间进行分组",
    "title": "使用 DuckDB 查找空缺的日期",
    "section": "2. 对时间进行分组",
    "text": "2. 对时间进行分组\n寻找缺失的日期, 主要难点在于按照时间连续性进行分组, 连续的时间放在同一个分组中, 这样如果一个 source_id 有多个时间段, 那么表示存在时间空缺.\n使用窗口函数, 对当前行的时间进行处理, 根据时间差, 获得当前行的分组时间. 代码如下:\n\ngroup_date_sql = \"\"\"\n SELECT \n    source_id,\n    end_date,\n    end_date - INTERVAL (ROW_NUMBER() OVER (PARTITION BY source_id ORDER BY end_date) - 1) DAY AS group_date\n  FROM df\n  order by source_id, end_date\n\"\"\"\ngrouped_date_df = conn.execute(group_date_sql).df()\ngrouped_date_df\n\n\n\n\n\n\n\n\nsource_id\nend_date\ngroup_date\n\n\n\n\n0\n1\n2024-07-01\n2024-07-01\n\n\n1\n1\n2024-07-02\n2024-07-01\n\n\n2\n1\n2024-07-03\n2024-07-01\n\n\n3\n1\n2024-07-05\n2024-07-02\n\n\n4\n1\n2024-07-06\n2024-07-02\n\n\n5\n2\n2024-07-01\n2024-07-01\n\n\n6\n2\n2024-07-02\n2024-07-01\n\n\n7\n2\n2024-07-03\n2024-07-01\n\n\n8\n3\n2024-07-01\n2024-07-01\n\n\n9\n3\n2024-07-02\n2024-07-01\n\n\n10\n3\n2024-07-03\n2024-07-01\n\n\n11\n3\n2024-07-04\n2024-07-01\n\n\n12\n3\n2024-07-05\n2024-07-01\n\n\n13\n3\n2024-07-06\n2024-07-01\n\n\n14\n3\n2024-07-07\n2024-07-01\n\n\n15\n3\n2024-07-08\n2024-07-01\n\n\n16\n3\n2024-07-09\n2024-07-01\n\n\n17\n4\n2024-07-05\n2024-07-05\n\n\n18\n4\n2024-07-06\n2024-07-05\n\n\n19\n4\n2024-07-07\n2024-07-05\n\n\n20\n4\n2024-07-08\n2024-07-05\n\n\n21\n4\n2024-07-09\n2024-07-05"
  },
  {
    "objectID": "posts/find_missing_dates_with_duckdb/index.html#根据-source_id-和分组时间分组",
    "href": "posts/find_missing_dates_with_duckdb/index.html#根据-source_id-和分组时间分组",
    "title": "使用 DuckDB 查找空缺的日期",
    "section": "3. 根据 source_id 和分组时间分组",
    "text": "3. 根据 source_id 和分组时间分组\n\ngroup_sql = \"\"\"\nSELECT \n    source_id,\n    MIN(end_date) AS start_date,\n    MAX(end_date) AS end_date,\n  FROM grouped_date_df\n  GROUP BY source_id, group_date\n  ORDER BY source_id, group_date\n\"\"\"\ngrouped_df = conn.execute(group_sql).df()\ngrouped_df\n\n\n\n\n\n\n\n\nsource_id\nstart_date\nend_date\n\n\n\n\n0\n1\n2024-07-01\n2024-07-03\n\n\n1\n1\n2024-07-05\n2024-07-06\n\n\n2\n2\n2024-07-01\n2024-07-03\n\n\n3\n3\n2024-07-01\n2024-07-09\n\n\n4\n4\n2024-07-05\n2024-07-09"
  },
  {
    "objectID": "posts/find_missing_dates_with_duckdb/index.html#可视化",
    "href": "posts/find_missing_dates_with_duckdb/index.html#可视化",
    "title": "使用 DuckDB 查找空缺的日期",
    "section": "4. 可视化",
    "text": "4. 可视化\n\n\nCode\nimport plotly.express as px\nfig = px.timeline(grouped_df, x_start='start_date', x_end='end_date', y='source_id')\nfig.update_yaxes(autorange=\"reversed\")\nfig.show()"
  },
  {
    "objectID": "posts/find_missing_dates_with_duckdb/index.html#完整代码",
    "href": "posts/find_missing_dates_with_duckdb/index.html#完整代码",
    "title": "使用 DuckDB 查找空缺的日期",
    "section": "5. 完整代码",
    "text": "5. 完整代码\n\nsql = \"\"\"\nwith raw_data as (\n  SELECT * FROM (\n    VALUES \n      (1, DATE '2024-07-01'),\n      (1, DATE '2024-07-02'),\n      (1, DATE '2024-07-03'),\n      (1, DATE '2024-07-05'),\n      (1, DATE '2024-07-06'),\n      (2, DATE '2024-07-01'),\n      (2, DATE '2024-07-02'),\n      (2, DATE '2024-07-03'),\n      (3, DATE '2024-07-01'),\n      (3, DATE '2024-07-02'),\n      (3, DATE '2024-07-03'),\n      (3, DATE '2024-07-04'),\n      (3, DATE '2024-07-05'),\n      (3, DATE '2024-07-06'),\n      (3, DATE '2024-07-07'),\n      (3, DATE '2024-07-08'),\n      (3, DATE '2024-07-09'),\n      (4, DATE '2024-07-05'),\n      (4, DATE '2024-07-06'),\n      (4, DATE '2024-07-07'),\n      (4, DATE '2024-07-08'),\n      (4, DATE '2024-07-09'),\n  ) AS t(source_id, end_date)\n), group_date as (\n  SELECT \n    source_id,\n    end_date,\n    end_date - INTERVAL (ROW_NUMBER() OVER (PARTITION BY source_id ORDER BY end_date) - 1) DAY AS group_date\n  FROM raw_data\n  order by source_id, end_date\n), final as (\n  SELECT \n    source_id,\n    MIN(end_date) AS start_date,\n    MAX(end_date) AS end_date,\n  FROM grouped_date_df\n  GROUP BY source_id, group_date\n  ORDER BY source_id, group_date\n)\nfrom final\n\"\"\"\ndate_df = conn.execute(sql).df()\ngap_fig = px.timeline(date_df, x_start='start_date', x_end='end_date', y='source_id')\ngap_fig.update_yaxes(autorange=\"reversed\")\ngap_fig.show()"
  }
]